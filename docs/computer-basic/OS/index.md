# OS笔记 - 基本概念速览

::: info 学习参考
- 黑书
- MIT6.S081
- 王道
- nju&jyy
:::




::: details 目录
[[toc]]
:::


::: danger 警告
下面内容仅做初学概念速览,为简化了解难度,内容不一定完整或严格正确
:::

## 什么是操作系统?

操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机地工作和资源地分配，以提供给用户和其他软件方便地接口和环境，它是计算机系统中最基本的系统软件

功能和目标:

- 作为系统资源的管理者
- 作为用户和计算机硬件之间的接口(命令接口(连机,脱机),程序接口(系统调用))
- 作为最接近硬件的层次

## 操作系统的特征（并发、共享、虚拟、异步） 

有并发才有共享,没有并发和共享,就谈不上虚拟和异步

### 并发
指在同一时刻,只能有一条指令执行,但多个进程指令被快速的轮换执行,使得在宏观上具有多个进程同时执行的效果

::: warning 并行和并发

- 并行: 指在同一时刻,有多条指令在多个处理器上同时执行
- 并发: 指在同一时刻,只能有一条指令执行

:::

### 共享

系统中的资源供多个并发进程共同使用

- 互斥共享
- 同时共享

### 虚拟

空分复用技术: 空间上的,虚拟内存

时分复用技术: 时间上的,虚拟处理器

### 异步

指系统中的各种操作出现的时间上的前后关系不一致

或者说由于资源有限,多个程序并发时无法合理确定每个进程的执行速度,这就是进程的异步性


## 操作系统的历史

- 手工操作阶段
- 批处理阶段(单道/多道)
- 分时操作系统(基于时间片,不能反应紧急)
- 实时操作系统

...

## 体系结构

### 基本概念
两指令,两处理器转态,两程序

- **指令**:特权与非特权

- **处理器状态**:利用PSW(程序状态字寄存器)决定是用户态还是核心态,用于鉴权,从而确定指令

- **程序**:相应的有两种程序,内核程序和普通的应用程序


### 操作系统内核

内核是操作系统最核心的部分,是操作系统的心脏

#### 微内核



负责时钟管理,中断处理,原语

:::info 什么是原语?

操作系统最接近底层的一系列特殊程序,运行具有原子性(不可中断),运行时间短,调用频繁  

比如设备驱动,cpu优化

:::

#### 大内核

进程管理,储存器管理,设备管理等功能+微内核部分

### 中断和异常

人们引入中断机制，从而实现多道程序并发执行

发生中断就意味着需要操作系统介入，开展管理工作

当中断发生的时候,CPU立刻进入核心态,中断当前进程,并由操作系统对中断进行处理

中断分为内中断和外中断

内中断分为指令中断(trap等)和强迫中断(故障等)

外中断如I/O操作完成,用户强制终止等

每条指令执行完后,cpu会判断是否有外部中断信号,然后决定是否保存当前的CPU环境并转入对应的中断程序


### 系统调用

“系统调用” 是指操作系统提供给应用程序（程序员 / 编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务

同时这也能保持安全性,让程序员无法直接操作高权限的内核

:::tip 系统调用与库函数
有些库函数封装了系统调用,以便在不同的系统之间实现兼容
:::

系统调用的简单流程: 传递系统调用参数->执行trap(用户态)->执行系统调用(核心态)->返回用户态



## 进程基础

### 进程的概念

引入进程概念,是为了实现并发执行

进程实体: 包括程序段(要执行的代码),数据段(运行过程处理的数据),进程控制块(PCB)

进程控制块(PCB): 用于描述进程,如id,进程状态,进程优先级,进程资源需求(程序段指针,数据段指针,键盘,鼠标),各种寄存器等

操作系统所需的数据都在PCB中,程序本身运行所需的数据在数据段与程序段中

PCB是进程实体的**唯一标志!**

从不同的角度,进程有不同的经典定义,而引入进程实体的概念以后,我们可以把进程定义为:

**进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位**

### 组织进程

如何对数以千计的进程进行管理和组织?

我们先进行分类,一般会将进程按进程状态分为执行,就绪,阻塞(可能细分)


#### 链接方式

根据分类,把PCB分为多个队列,操作系统持有指向各个队列的指针

#### 索引方式

同理分为多个索引表,并给对应多个索引表的指针

### 进程的特征

- 动态性: 进程是程序的一次执行过程,是动态产生变化与消失的
- 并发性: 各个进程可并发执行
- 独立性: 进程是能独立运行,接受资源分配与调度的基本单位
- 异步性: 速度不可预知,操作系统需要提供进程同步机制来解决问题
- 结构性: 每个进程都有PCB+程序段+数据段

### 进程的状态

一般有5种,最重要的三种在[组织进程](#组织进程)中我们提到过:

- 运行态: 占CPU,并在CPU上运行
- 就绪态: 具备运行条件,但没有具体的CPU
- 阻塞态(也就是等待态): 因等待某件事暂时不能执行

进程的另外两种状态：

- 创建态（New，又称新建态）：进程正在被创建，操作系统为进程分配资源、初始化PCB
- 终止态（Terminated，又称结束态）：进程正在从系统中撤销，操作系统会回收进程拥有得资源、撤销PCB

经典裤衩图:

略

### 进程控制

> 进程控制就是要实现进程状态的转换

进程状态的转换所要做的一些事比如:

- 除去New和Terminated状态,进程状态的转换都需要修改PCB
- 运行态切到就绪或者阻塞的时候要保留运行环境
- 就绪态到运行态要恢复运行环境
- 到终止态要回收资源

**原语**可以实现进程控制,原语曾在上面[微内核](#微内核)部分介绍过,其最大的特征就是不允许中断

在原语执行开始会发出"关中断"的指令,在原语执行结束会发出"开中断"的指令,"关中断"期间内的中断信号会被操作系统忽略

显然开关中断是基于系统的特权命令

### 进程通信

进程是分配系统资源的单位,因此各个进程之间拥有的内存地址空间相互独立,为了安全,进程不允许直接访问另一个进程的地址空间

这个时候需要进程通信,一般分为以下三种

#### 共享存储

两个进程拥有一个共享空间,对于一个共享空间需要互斥访问

共享存储可分为基于数据结构和基于储存区

数据结构效率低限制多,是一种低级通信

储存区会在内存画出一片共享储存区,内容均有进程自己控制(而非操作系统),权限大,速度快,属于高级通信

#### 管道通信

管道是用于链接读写进程的共享文件,又名pipe,是在内存区开辟的固定大小的缓冲区

- 一个管道只能采用半双工通信,同一个时间段只能单向,如果要双向通信,要至少两个管道
- 管道访问也需要互斥
- 管道没写满不许读,没读空不许写(保证某个时段只能单向,基于阻塞write和read实现)


#### 消息传递

将信息格式化为消息(消息头+消息体),发送方将消息发送给接收方,接收方再将消息读取出来

系统会提供发送和接受原语

消息传递分为:

- 消息缓存队列读取
- 间接信箱读取

## 线程基础

为什么要引入线程?**增加并发度!**

线程是轻量级的进程,创建新线程的时候不需要重新分配资源和切换进程环境,因此大大减少了并发的开销,增加了并发的灵活度

### 线程的属性

- 处理机调度单位
- 线程可占据不同的CPU
- 线程有自己的ID和TCB(线程控制块)
- 也有三种基本状态
- 几乎不占用系统资源
- 同一进程下共享进程资源
- 由于共享资源,因此线程间通信比进程间通信更简单,基本上无需操作系统干预(如提供原语等)
- 非跨进程间的线程切换,不会引起进程切换
- 同进程切换系统开销极小

### 线程的实现方式

- 用户级线程: 应用程序通过进程库实现,所有线程工作(创建,切换,销毁)都由应用程序负责,操作系统无法感知
- 内核级线程: 由OS内核完成,调度切换等由OS完成,因此内核级的切换在核心态下实现
- 组合: n个用户线程映射到m个内核线程,n>=m,但实际上内核线程才是实际的系统处理单位

### 多线程模型

- 多对一模型: 多个用户线程映射到一个内核线程,用户线程的切换成本低(在用户空间即可完成),效率高,但是一个用户线程阻塞,整个进程都会被阻塞,并发度低
- 一对一模型: 每个用户线程映射到一个内核线程,用户线程的切换成本高(在内核空间完成),效率低,但是一个用户线程阻塞,其他用户线程不受影响
- 多对多模型: 好,但实现复杂

## 处理机的调度

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理时，就需要确定某种规则来决定处理这些任务的顺序，这就是 “调度” 研究的问题。在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个**进程**。处理机调度，就是从就绪队列中按照一定地算法选择一个进程并将处理机分配给它运行，以实现进程地并发执行。

:::info 狭义与广义
- 狭义调度指的是从队列选择一个进程
- 广义调度指的是从队列选择一个进程，并进行进程切换
:::

### 调度层次

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序


#### 低级调度

低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次

#### 中级调度

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。  

暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。  

中级调度 (内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。  

每个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

:::info 七状态
暂时调到外存等待的进程状态为挂起状态 (挂起态，suspend)  
挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态  
:::

#### 高级调度

高级调度 (作业调度) 。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个) 作业给他们分配内存等必要资源，并建立相应的进程(建立PCB) ，以使它(们)获得竞争处理机的权利。

高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

:::tip 与中级调度的区别
这里是是创建PCB和撤销PCB,中级调度会保留PCB至内存

更本质的来说,高级调度是创建进程,而中级调度只是切换进程的状态
:::

### 不能调度的情况

- 原语
- 进程处于OS内核程序临界区
- 在中断过程中进行进程切换(?)

### 调度的时机

- 主动
- 被动

### 调度的方式

- 剥夺
- 非剥夺

### 评价指标

- CPU 利用率: 指 CPU “忙碌” 的时间占总时间的比例
- 系统吞吐量: 单位时间内完成作业的数量
- 周转时间: 周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
- 带权周转时间=所有作业周转时间之和/作业数
- 带权周转时间: 周转时间/实际运行时间(在CPU上)
- 平均带权周转时间=所有作业带权周转时间和/作业数
- 响应时间: 指从用户提交请求到首次产生响应所用的时间
- 等待时间: 除去I/O等待的所有等待时间之和,从作业等待高度调度建立进程开始算

### 调度算法:star:

#### 先来先服务（FCFS，First Come First Server）

内容如题


#### 短作业优先（SJF，Shortest Job First）

- 服务时间短的优先
- 可用于高级和低级调度,用于低级调度的称为(SPF,短进程优先)
- 非抢占(非剥夺),也就是说如果当前进程用时长的已经在运行,并不会让刚到达的运行短的任务抢上去
- 优点: 优化时间
- 缺点: 会产生饥饿现象,即运行时间长的线程可能会一直等待,同时运行时间为用户提供,不一定为实际运行时间

#### 最短剩余时间优先算法 SRTN
抢占版的SJF和SPF

#### 高响应比优先（HRRN， Highest Response Ratio Next）

- 综合考虑SJF和FCFS的均衡解法
- 根据响应比,越大越优先,响应比=(等待时间+要求服务时间)/要求服务时间
- 非抢占
- 不会导致饥饿
- 可用于高级和低级调度

---

#### 时间片轮转调度算法（RR，Round-Robin）

- 分时
- 只用于进程调度(低级调度)
- 超时就换(基于时钟中断),强制剥夺
- 时间片过长退化为FCFS;过短切换开销过大

#### 优先级调度算法

按照优先级来处理

#### 多级反馈队列调度算法

设置多级就绪队列，各级队列优先级从高到低，时间片从小到大新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾如果此时已经是在最下级的队列，则重新放回该队列队尾只有第k 级队列为空时，才会为 k+1 级队头的进程分配时间片

抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾

优点: 快速响应,耗时短的进程很快完成,相对公平(没有优先级)

不估计运行时间,但可能会饥饿